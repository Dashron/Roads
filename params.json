{
  "name": "Roads",
  "tagline": "A node.js web framework",
  "body": "# The Roads.js isomorphic web framework\r\n\r\nRoads is a web framework built on Generators. It's similar to Koa.js, but can be used both in the browser and on the server.\r\n\r\n# Why should I use Roads?\r\n\r\n1. Roads can be attached to any node HTTP server, including Koa.js, Express.js, and the built in node HTTP server.\r\n2. Roads is isomorphic, meaning you can generate html on the server or in the browser with the same code.\r\n3. Roads lets you work without callbacks. It's built on top of promises and generator-based coroutines.\r\n4. Roads can be run without ever attaching it to an HTTP server. This is great for writing tests, working with web sockets, or writing API first websites. \r\n\r\n\r\n# Build Status\r\n![Build status](https://travis-ci.org/Dashron/roads.svg?branch=master)\r\n\r\n# Index\r\n\r\n - [Getting Started](#getting-started)\r\n - [Roads.Road](#roadsroad)\r\n  - [new Road()](#new-road)\r\n  - [use(*Function* fn)](#roadusefunction-fn)\r\n  - [request(*string* method, *string* url, *dynamic* body, *Object* headers)](#roadrequeststring-method-string-url-dynamic-body-object-headers)\r\n - [Roads.Response](#roadsresponse)\r\n  - [new Response(*mixed* body, *number* status, *Object* headers)](#new-responsemixed-body-number-status-object-headers)\r\n  - [body](#body)\r\n  - [status](#status)\r\n  - [headers](#headers)\r\n  - [writeTo(*ServerResponse* httpResponse)](#responsewritetoserverserverresponse-http_response)\r\n - [Roads.HttpError](#roadshttperror)\r\n  - [new HttpError(*string* message, *number* code)](#new-httperrorstring-message-number-code)\r\n - [Roads.middleware](#roadsmiddleware)\r\n  - [killSlash()](#killslash)\r\n  - [cors(*Array|string* allow_origins, *Array* allow_headers)](#corsarraystring-allow_origins-array-allow_headers)\r\n  - [SimpleRouter](#simplerouter)\r\n   - [SimpleRouter.applyMiddleware(road)](#simplerouterapplymiddlewareroad)\r\n   - [Road.addRoute(*string* method, *string* path,*function* fn)](#roadaddroutestring-method-string-path-function-fn)\r\n - [Roads.build](#roadsbuildstring-input_file-string-output_file-object-options)\r\n - [Roads.PJAX(*Object* road, *DomElement* container_element, *Object* window)](#roadspjaxobject-road-domelement-container_element-object-window)\r\n  - [register()](#pjaxregister)\r\n  - [PJAX Link Format](#pjax-link-format)\r\n  - [PJAX Page titles](#pjax-page-titles)\r\n  - [Isomorphic PJAX tips](#isomorphic-pjax-tips)\r\n\r\n## Getting Started\r\n\r\nBuilding a project with roads is very straightforward.\r\n\r\n1. Create your Road object\r\n    ```\r\n    const roads = require('roads');\r\n    var road = new Road();\r\n\t```\r\n\r\n2. Add code to the road\r\n    ```\r\n    const roads = require('roads');\r\n    var road = new Road();\r\n    road.use(function (method, path, body, headers) {\r\n        console.log('A ' + method + ' request was made to ' + path);\r\n    });\r\n    ```\r\n\r\n5. Run your code.\r\n\r\n - You can tie the road to node's standard HTTP Server. This will automatically route any HTTP requests to that server into your road.\r\n        ```node\r\n        const roads = require('roads');\r\n\r\n        var road = ...; // See steps 1 and 2 for road construction\r\n        var server = new roads.Server(road, function (error) {\r\n            console.log('roads encountered an error', error);\r\n        });\r\n\r\n        server.listen(8080);\r\n        ```\r\n\r\n - You can use the road as a router for your Koa.js server.\r\n        ```node\r\n        // Tie to node's HTTP server\r\n        const roads = require('roads');\r\n        const koa = require('koa');\r\n\r\n        var road = ...; // See steps 1 and 2 for road construction\r\n        var app = koa();\r\n        app.use(roads.integrations.koa(road));\r\n        app.listen(8080);\r\n        \r\n        ```\r\n\r\n - You can Manually execute a resource method. This will behave just like a web request without having to use HTTP.\r\n\r\n\t```node\r\n        // Tie to node's HTTP server\r\n        const roads = require('roads');\r\n\r\n        var road = ...; // See steps 1 and 2 for road construction\r\n\r\n    \t// Call directly\r\n    \troad.request('GET', '/users', {page: 2})\r\n    \t    .then(function (response) {\r\n    \t        console.log(response);\r\n    \t    });\r\n\t```\r\n - You can use browserify to compile everything for use in the browser.\r\n    \r\n    **client_index.js**\r\n    ```node\r\n        const roads = require('roads');\r\n        var road = ...; // See steps 1 and 2 for road construction\r\n\r\n        // Make a client side request. See the PJAX section of the docs for more client side options\r\n        road.request('GET', '/users', {page: 2})\r\n            .then(function (response) {\r\n                console.log(response);\r\n            });\r\n\r\n    ```\r\n\r\n    **build.js**\r\n    ```node\r\n        require('roads').build('client_index.js', '/build/client.js', {\r\n            roads: {\r\n                output_file: './build/roads.js',\r\n            }\r\n        });\r\n\r\n    ```\r\n\r\n\r\nNow that you can use your road, continue reading the docs below for more information on [routers](#simplerouter), [error handling](#roadusefunction-fn), [PJAX support](#roadspjaxobject-road) and more!\r\n\r\n\r\n\r\n## Roads.Road\r\n\r\nA Road is a container that holds an array of functions. It exposes a [request](#requeststring-method-string-url-dynamic-body-object-headers) method which allows you to execute the functions and provide consistent parameters..\r\n\r\n### new Road()\r\n**Create a Road.**\r\n\r\nCreates your Road object. \r\n\r\n```node\r\nconst roads = require('roads');\r\nvar road = new roads.Road();\r\n```\r\n\r\n\r\n### Road.use(*Function* fn)\r\n**Add a custom function that will be executed before every request.**\r\n\r\nThis function can be called one or more times. Each time it is called, the provided function will be added to a queue that is executed when you call the [request](#roadrequeststring-method-string-url-dynamic-body-object-headers) method. The execution order will match the order the functions were added to the road. Each function can choose whether or not it wants to progress to the following middleware function by calling or ignoring the `next` method.\r\n\r\n name | type                                                                  | required | description\r\n -----|-----------------------------------------------------------------------|----------|---------------\r\n fn   | Function(*string* method, *string* url,*object* body,*object* headers,*function* next) | yes      | Will be called any time a request is made on the object.\r\n \r\n This will be called for every request, even for routes that do not exist. The callback will be executed with the following five parameters:\r\n \r\n#### use Callback \r\n**function (*string* method,*string* url, *Object* body, *Object* headers, *Function* next)**\r\n\r\nname     | type                               | description\r\n --------|------------------------------------|---------------\r\n method  | string                             | The HTTP method that was provided to the request\r\n url     | string                             | The URL that was provided to the request\r\n body    | object                             | The body that was provided to the request, after it was properly parsed into an object\r\n headers | object                             | The headers that were provided to the request\r\n next    | function                           | The next step of the handler chain. If there are no more custom handlers assigned, next will resolve to the [resource method](#resource-method) that the router located. This method will always return a promise.\r\n\r\nIf the callback does not return a [response](#roadsresponse) object, the return value will become the body of a new [response](#roadsresponse) object with the default status code of 200.\r\n\r\n```node\r\n// Example of a request handler that kills trailing slashes (This is provided for you in the middleware!)\r\n// The main logic of this function will be executed before the resource method, because it all happens before the middleware calls next()\r\nroad.use(function (method, url, body, headers, next) {\r\n\t// kill trailing slash as long as we aren't at the root level\r\n    if (url.path != '/' && url.path[url.path.length - 1] === '/') {\r\n        return new roads.Response(null, 302, {\r\n            location: url.path.substring(0, url.path.length - 1)\r\n        });\r\n    }\r\n\r\n    return next();\r\n});\r\n\r\n// Example of a request handler that catches errors and returns Response objects\r\n// The main logic of this function will execute after the resource method,  because it all happens after the middleware calls next()\r\nroad.use(function(method, url, body, headers, next) {\r\n    // execute the actual resource method, and return the response\r\n    return next()\r\n        // Catch any errors that are thrown by the resources\r\n        .catch (function (err) {\r\n            // Wrap the errors in response objects. If they are [HttpErrors](#roadshttperror) we adjust the status code\r\n            switch (err.code) {\r\n                case 404:\r\n                    return new roads.Response(notFoundRepresentation(err), 404);\r\n                case 405:\r\n                    return new roads.Response(notAllowedRepresentation(err), 405);\r\n                case 500:\r\n                default:\r\n                    return new roads.Response(unknownRepresentation(err), 500);\r\n            }\r\n        });\r\n});\r\n```\r\n\r\n\r\n### Road.request(*string* method, *string* url, *dynamic* body, *Object* headers)\r\n**Locate and execute the resource method associated with the request parameters.**\r\n\r\n\r\nThis function will execute all of the functions assigned via [use](#roadusefunction-fn) in the order they were assigned and return a [thenable (Promises/A compatible promise)](http://wiki.commonjs.org/wiki/Promises/A). The thenable will always resolve to a [Response](#roadsresponse) object.\r\n\r\nIf the system encounters an unexpected error, it will try to throw an [HttpError](#roadshttperror) with a 500 status code. There may be circumstances where we were unable to wrap the exception with an HttpError, so be sure to check whether or not your exceptions are `instance of HttpError`.\r\n\r\n\r\n```node\r\nvar promise = road.request('GET', '/users/dashron');\r\n\r\npromise.then(function (response) {        \r\n    console.log(response);\r\n});\r\n\r\npromise.catch(function (error) {\r\n    console.log(error);\r\n});\r\n```\r\n\r\n##### Context\r\nEach middleware function has access to a request context through ```this```. Each ```this``` will be unique to the request, and will persist from each request handler (assigned via `use`) into the actual request. The context is pre-loaded with two variables, listed below.\r\n\r\nname             | type     | description\r\n ----------------|----------|---------------\r\nrequest          | function | An alias for [Road.request](#roadrequeststring-method-string-url-dynamic-body-object-headers). If you need to make a request from within middleware, it is recommended to use this instead of `Road.request`.\r\nResponse         | Response | The Response constructor. Every request *should* return a `Response`, so this is provided to simplify the process. If you are constructing a `Response` from within middleware it is recommended that you use this instead of `Roads.Response`.\r\n\r\n\r\n```node\r\nvar road = new Road();\r\nroad.use(function (method, url, body, headers) {\r\n    // true because the middleware persists to this context\r\n    console.log(this.uri === '/me');\r\n\r\n\r\n    // Easy access to the response object\r\n    return new this.Response('hello world', 200);\r\n});\r\n\r\nroad.request('GET', '/me').then(function (response) {\r\n    console.log(response);\r\n});\r\n```\r\n\r\nMiddleware is encouraged to add variables to this context to simplify development. Make sure to namespace your variables to ensure there are no conflicts with other librares.\r\n\r\neg:\r\n```node\r\nvar road = new Road();\r\nroad.use(function (method, url, body, headers) {\r\n    this.context.my_project.require_authentication = true;\r\n});\r\n```\r\n\r\n## Roads.Response\r\n\r\nThe response object contains all of the information you want to send to the client. This includes the body, status code and all applicable headers. \r\n\r\n\r\n### new Response(*mixed* body, *number* status, *Object* headers)\r\n**Constructor**\r\n\r\nname        | type                               | description\r\n -----------|------------------------------------|---------------\r\n body       | mixed                              | The body of the response.\r\n status     | number                             | The HTTP Status code.\r\n headers    | object                             | Key value pairs of http headers.\r\n\r\nCreate a response object. \r\n\r\n```node\r\nnew Response({\"uri\": \"...\"}, 200, {\"last-modified\":\"2014-04-27 00:00:00\"});\r\n```\r\n\r\n### Body\r\n**The raw JavaScript object returned by the request**\r\n\r\n```node\r\nconsole.log(response.body);\r\n```\r\n\r\n### Status\r\n**The HTTP status returned by the request**\r\n\r\n```node\r\nconsole.log(response.status);\r\n```\r\n\r\n### Headers\r\n**A JavaScript object of all response headers**\r\n\r\n```node\r\nconsole.log(response.headers);\r\n```\r\n\r\n\r\n### Response.writeToServer(*ServerResponse* http_response)\r\n**A helper function to write the response object to a server response**\r\n\r\nThis will apply the body, status code, and any applicable headers to the provided http_response. It will not end the response, so you need to do that yourself. If the body is a JavaScript object, and no content-type header is set, the response will be sent through JSON.stringify, and the content-type header will be set to `application/json`.\r\n\r\n```node\r\n// Use middleware to automatically apply a response wrapper\r\nroad.use(roads.middleware.standard());\r\n\r\n// execute the route logic and retrieve the appropriate response object\r\nroad.request(http_request.method, http_request.url, body, http_request.headers)\r\n    .then(function (response) {\r\n        // Write the response to the server\r\n        response.writeToServer(http_response);\r\n        http_response.end();\r\n    })\r\n    .catch(function (error) {\r\n        // be careful throwing an error in a response like this\r\n        // errors might expose sensitive data\r\n        (new roads.Response(error, 500)).writeToServer(http_response);\r\n        http_response.end();\r\n    });\r\n```\r\n\r\n\r\n## Roads.HttpError\r\n\r\n### new HttpError(*string* message, *number* code)\r\n**A helper error, that contains information relevant to common HTTP errors**\r\n\r\nname        | type                               | description\r\n -----------|------------------------------------|---------------\r\n message    | string                             | A message describing the HTTP error\r\n code       | number                             | An official [http status code](#http://www.httpstatus.es)\r\n\r\n```node\r\nthrow new Roads.HttpError('Page not found', 404);\r\n```\r\n\r\n### Constants\r\n\r\nThese constants make it easier to keep track of some common error status codes. For more information on what they mean, check out (httpstatus.es)[http://httpstatus.es]\r\n\r\n```\r\nHttpError.invalid_request = 400;\r\nHttpError.unauthorized = 401;\r\nHttpError.forbidden = 403;\r\nHttpError.not_found = 404;\r\nHttpError.method_not_allowed = 405;\r\nHttpError.not_acceptable = 406;\r\nHttpError.conflict = 409;\r\nHttpError.gone = 410;\r\nHttpError.unprocessable_entity = 422;\r\nHttpError.too_many_requests = 429;\r\nHttpError.internal_server_error = 500;\r\n```\r\n\r\n## Roads.middleware\r\n\r\n### killSlash()\r\n**Middleware to kill the trailing slash on http requests**\r\n\r\nIf used, any url that ends with a trailing slash will return a response object redirecting the client to the same url without the trailing slash (302 redirect with Location: [url_without_slash])\r\n\r\n```node\r\nroad.use(roads.middleware.killSlash);\r\n```\r\n\r\n### cors(*Array|string* allow_origins, *array* allow_headers)\r\n**Middleware to Apply proper cors headers**\r\n\r\nSets up the proper preflight, and standard repsonse headers so that browsers can make proper CORS requests.\r\n\r\nname            | type                               | description\r\n ---------------|------------------------------------|---------------\r\n allow_origins  | Array|string                       | Either * to allow all origins, or an explicit list of valid origins.\r\n allow_headers  | Array                              | (optional) A white list of headers that the client is allowed to send in their requests\r\n\r\n```node\r\nroad.use(roads.middleware.cors(['http://localhost:8080'], ['authorization']));\r\n```\r\n\r\n### SimpleRouter()\r\n\r\n**TODO:** Docs. See the testSimpleRouter.js file in the meanwhile.\r\n\r\n#### SimpleRouter.applyMiddleware(road)\r\n\r\n#### Road.addRoute(*string* method, *string* path, *function* fn)\r\n\r\n\r\n## Roads.build(*string* input_file, *string* output_file, *object* options)\r\n**Browserify function to convert your script to run in the browser**\r\n\r\nname                    | type                               | description\r\n -----------------------|------------------------------------|---------------\r\n input_file             | string                             | The source file that will be converted to use in the browser\r\n output_file            | string                             | The output file that will be accessible by your browser\r\n options                | object                             | A set of options that can influence the build process. See all fields below\r\n options.babelify       | object                             | An object containing parameters to pass to the babelify transform\r\n options.envify         | object                             | An object to pass to envify. This allows you to change values between your server and client scripts.\r\n options.exclude        | array                              | An array of files that should not be included in the build process.\r\n options.external       | array                              | An array of dependencies that should be included from exernal resources instead of built into the project\r\n options.use_sourcemaps | boolean                            | Whether or not the build process should include source maps.\r\n\r\n\r\n```\r\nrequire('roads')\r\n    .build(__dirname + '/static/client.js', __dirname + '/static/client.brws.js', {\r\n        use_sourcemaps: true,\r\n        external: {\r\n            roads: {\r\n                output_file: __dirname + '/static/roads.brws.js',\r\n            }, \r\n            react: {\r\n                output_file: __dirname + '/static/react.brws.js',\r\n            }\r\n        },\r\n        babelify: {presets: ['react']}\r\n    });\r\n```\r\n\r\n## Roads.PJAX(*Object* road, *DomElement* container_element, *Object* window)\r\n**A helper object to easily enable PJAX on your website using roads**\r\n\r\nPJAX stands for pushState + AJAX. PJAX a technique for speeding up webpages by replacing certain links on the page with AJAX calls. To enable PJAX, you must create a PJAX object and call the register method. Until you call register, PJAX links will not be handled properly.\r\n\r\n### PJAX.register()\r\n\r\nOn page load, you will need to construct and register your PJAX handler. When you click certain links in the container element, PJAX will intercept the action and instead use roads to generate the new page content. Once the new html is ready, it will replace the innerHTML of the container_element.\r\n\r\nThis allows for clean, quick page refreshes via JavaScript, with a safe, JavaScript free fallback (the links will still work as normal without JavaScript!).\r\n\r\n```\r\nvar road = ...; // Incomplete. See the getting started section for more information about creating a road\r\nvar pjax = new require('roads').PJAX(road, document.getElementById('container'), window);\r\npjax.register();\r\n```\r\n\r\n### PJAX Link Format\r\n\r\nIf you would like a link to run via PJAX instead of a new page load, simply add the following data attribute\r\n\r\n`data-roads=\"link\"`\r\n\r\ne.g.\r\n\r\n`<a href=\"/home\" data-roads=\"link\">Home</a>`\r\n\r\n### PJAX Page titles\r\n\r\nTo handle page titles you will need to add matching middleware to your server, and your client road. Roads already includes a simple form of this via the setTitle middleware, and the PJAX function addTitleMiddleware.\r\n\r\nYour server should include the following:\r\n\r\n```node\r\nvar roads = require('roads');\r\nvar road = ...; // Incomplete. See the getting started section for more information about creating a road\r\nroad.use(roads.middleware.setTitle);\r\n```\r\n\r\n```node\r\n\r\nvar roads = require('roads');\r\nvar road = ...; // Incomplete. See the getting started section for more information about creating a road\r\n\r\nvar pjax = new roads.PJAX(road);\r\npjax.addTitleMiddleware();\r\npjax.register(window, document.getElementById('container'));\r\n```\r\n\r\n### Isomorphic PJAX tips\r\n\r\nThere's a very easy pattern to follow to ensure sharing client and server code works successfully via PJAX.\r\n\r\n1. Your layout (everything wrapping the PJAX container) should be added via middleware. This middleware should not be used when built in the client.\r\n2. You should have one road that contains all of your public controllers, and one road that contains all of your private controllers\r\n3. Your public controller should only contain public data, and interact with the rest of your system via HTTP. e.g. instead of making DB calls, these controllers would make HTTP requests to a separate API. This pattern is GREAT, and worthy of another entire article.\r\n4. Private controllers aren't absolutely necessary, but may come into play if you need authentication or filesystem access for certain pages.\r\n\r\n\r\n### TODO:\r\n\r\n- Now that the opinionated router has been split out, it needs to be rebuilt into middleware, matching simplerouter as closely as possible.\r\n- Improved PJAX test coverage\r\n- Unit tests for HTTPServer class\r\n- Examples of koa and other middleware\r\n- Revise documentation to more clearly describe new middleware-only system\r\n- Add code coverage libraries\r\n- Directly reference the field-filter system from this library (or just build that new representation class)\r\n- Should roads-client be in this library?\r\n",
  "google": "UA-45276947-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}