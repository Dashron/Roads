<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Roads : A node.js web framework">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Roads</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Dashron/roads">View on GitHub</a>

          <h1 id="project_title">Roads</h1>
          <h2 id="project_tagline">A node.js web framework</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Dashron/roads/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Dashron/roads/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="the-roadsjs-api-framework" class="anchor" href="#the-roadsjs-api-framework"><span class="octicon octicon-link"></span></a>The Roads.js API Framework</h1>

<p>Roads is a framework for creating APIs in node.js. It requires generator support, so you should be using node 0.11.13 or higher with the <code>--harmony</code> flag enabled.</p>

<h1>
<a name="why-should-i-use-roads" class="anchor" href="#why-should-i-use-roads"><span class="octicon octicon-link"></span></a>Why should I use Roads?</h1>

<ol>
<li>It helps build an organized, resource oriented API through a nested routing structure.</li>
<li>It can be required right from your code, or called over HTTP.</li>
<li>It supports yield, for cleaner code.</li>
<li>It supports delayed response execution. If your users don't want certain fields, the code associated will never be run</li>
</ol>

<h1>
<a name="index" class="anchor" href="#index"><span class="octicon octicon-link"></span></a>Index</h1>

<ul>
<li>
<a href="#roadsapi">Roads.API</a>

<ul>
<li><a href="#new-apiresource-root_resource">new API(<em>Resource</em> root_resource)</a></li>
<li><a href="#apionerrorfunction-fn">onError(<em>Function</em> fn)</a></li>
<li><a href="#apionrequestfunction-fn">onRequest(<em>Function</em> fn)</a></li>
<li><a href="#apirequeststring-method-string-url-dynamic-body-object-headers">request(<em>string</em> method, <em>string</em> url, <em>dynamic</em> body, <em>Object</em> headers)</a></li>
<li><a href="#apiserverincomingmessage-http_request-serverresponse-http_response">server(<em>IncomingMessage</em> http_request, <em>ServerResponse</em> http_response)</a></li>
</ul>
</li>
<li>
<a href="#roadsresource">Roads.Resource</a>

<ul>
<li><a href="#new-resourceobject-definition">new Resource(<em>Object</em> definition)</a></li>
<li><a href="#url-part">URL Part (routing)</a></li>
<li><a href="#resource-method">Resource method</a></li>
</ul>
</li>
<li>
<a href="#roadsresponse">Roads.Response</a>

<ul>
<li><a href="#new-responsedynamic-data-number-status-object-headers">new Response(<em>Object</em> data, <em>number</em> status, <em>Object</em> headers)</a></li>
<li><a href="#responsegetdata">getData()</a></li>
<li><a href="#responsewritetoserverserverresponse-http_response">writeTo(<em>ServerResponse</em> httpResponse)</a></li>
</ul>
</li>
<li>
<a href="#roadsfieldsfilter">Roads.FieldsFilter</a>

<ul>
<li><a href="#new-fieldsfilterdynamic-data">new FieldsFilter(<em>dynamic</em> data)</a></li>
<li><a href="#filterarray-fields">filter(<em>Array</em> fields)</a></li>
</ul>
</li>
<li>
<a href="#roadshttperror">Roads.HttpError</a>

<ul>
<li><a href="#new-httperrorstring-message-number-code">new HttpError(<em>string</em> message, <em>number</em> code)</a></li>
</ul>
</li>
</ul>

<h2>
<a name="roadsapi" class="anchor" href="#roadsapi"><span class="octicon octicon-link"></span></a>Roads.API</h2>

<p>The API is a container that holds a series of Resource objects. It exposes a <a href="#apirequeststring-method-string-url-dynamic-body-object-headers">request</a> method which allows you to interact directly with resources.</p>

<p>To create all of your api endpoints, you start with the root_resource, and assign sub-<a href="#roadsresource">resources</a>.</p>

<h3>
<a name="new-apiresource-root_resource" class="anchor" href="#new-apiresource-root_resource"><span class="octicon octicon-link"></span></a>new API(<em>Resource</em> root_resource)</h3>

<p><strong>API Constructor</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>root_resource</td>
<td><a href="#roadsresource">Resource</a></td>
<td>yes</td>
<td>Used to generate the <a href="#roadsresponse">response</a> for the root endpoint ( [protocol]://[host]/ ).</td>
</tr>
</tbody>
</table>

<p>Creates your API object, so you can use it directly or bind it to an <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">HTTP server</a>. </p>

<pre lang="node"><code>var roads = require('roads');
var root_resource = new roads.Resource(...); // The resource definition has not been set here, because it's out of the scope of this example. Take a look at &lt;link&gt; for information about the Resource constructor.
var api = new roads.API(root_resource);
</code></pre>

<h3>
<a name="apionerrorfunction-fn" class="anchor" href="#apionerrorfunction-fn"><span class="octicon octicon-link"></span></a>API.onError(<em>Function</em> fn)</h3>

<p><strong>Assign an error handler to the API object</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>Function(<em>Error</em> error)</td>
<td>Yes</td>
<td>A callback that will be executed any time an error is thrown from within a resource, or from the API object. The only parameter will be an <code>error</code> object.</td>
</tr>
</tbody>
</table>

<p>This callback can return a Response object, which will be rendered for the user if possible.</p>

<p>Independent of any errors thrown by your resources, the API object can surface one of three errors.</p>

<table>
<thead>
<tr>
<th>type</th>
<th>message</th>
<th>status</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpError</td>
<td>The request pathname</td>
<td>404</td>
<td>If the endpoint could not be found</td>
</tr>
<tr>
<td>HttpError</td>
<td>An array of HTTP methods that can be requested for this resource</td>
<td>405</td>
<td>If the endpoint was found, but the HTTP method was not supported</td>
</tr>
<tr>
<td>Other (likely Error)</td>
<td>Dependant on the error</td>
<td>500</td>
<td>If any other error is thrown</td>
</tr>
</tbody>
</table>

<pre lang="node"><code>var api = new roads.API(root_resource);
api.onError(function (error) {
    console.log(error);
    switch (error.code) {
        case 404:
            return new roads.Response(notFoundRepresentation(error), 404); 
        case 405:
            return new roads.Response(notAllowedRepresentation(error), 405); 
        case 500:
        default:
            return new roads.Response(unknownRepresentation(error), 500); 
    }
});
</code></pre>

<h3>
<a name="apionrequestfunction-fn" class="anchor" href="#apionrequestfunction-fn"><span class="octicon octicon-link"></span></a>API.onRequest(<em>Function</em> fn)</h3>

<p><strong>Add a custom handler for every request.</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>Function(<em>string</em> method, <em>string</em> url,<em>object</em> body,<em>object</em> headers,<em>function</em> next)</td>
<td>yes</td>
<td>Will be called any time a request is made on the API object.</td>
</tr>
</tbody>
</table>

<p>This will be called for every request, even for routes that do not exist. The callback will be provided four parameters</p>

<h4>
<a name="onrequest-callback" class="anchor" href="#onrequest-callback"><span class="octicon octicon-link"></span></a>onRequest Callback</h4>

<p><strong>function (<em>string</em> method,<em>string</em> url, <em>Object</em> body, <em>Object</em> headers, <em>Function</em> next)</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>method</td>
<td>string</td>
<td>The HTTP method that was provided to the request</td>
</tr>
<tr>
<td>url</td>
<td>string</td>
<td>The url that was provided to the request</td>
</tr>
<tr>
<td>body</td>
<td>object</td>
<td>The body that was provided to the request, after it was properly parsed into an object</td>
</tr>
<tr>
<td>headers</td>
<td>object</td>
<td>The headers that were provided to the request</td>
</tr>
<tr>
<td>next</td>
<td>function</td>
<td>The <a href="#resource-method">resource method</a> that this request expected. You may optionally execute this method. If you provide a parameter, it will become the fourth parameter of the <a href="#resource-method">resource method</a>.</td>
</tr>
</tbody>
</table>

<p>This callback must return a response object. You do not have to return the response from the <code>next</code> method, you can return an entirely different response object.</p>

<pre><code>// Example of an onRequest handler
api.onRequest(function* (url, body, headers, next) {
    // kill trailing slash as long as we aren't at the root level
    if (url.path != '/' &amp;&amp; url.path[url.path.length - 1] === '/') {
        return new roads.Response(null, 302, {
        location : url.path.substring(0, url.path.length - 1)
    });
}

// This would also be a good place to identify the authenticated user, or api app and add it to the current request context
// eg: this.cur_user = user;

// execute the actual resource method, and return the response
    return next();
});
</code></pre>

<h3>
<a name="apirequeststring-method-string-url-dynamic-body-object-headers" class="anchor" href="#apirequeststring-method-string-url-dynamic-body-object-headers"><span class="octicon octicon-link"></span></a>API.request(<em>string</em> method, <em>string</em> url, <em>dynamic</em> body, <em>Object</em> headers)</h3>

<p><strong>Make a request to the API.</strong></p>

<p>This function will locate the appropriate <a href="#resource-method">resource method</a> for the provided parameters, execute it and return a <a href="http://wiki.commonjs.org/wiki/Promises/A">thenable (Promises/A compatible promise)</a>.
On success, you will receive a <a href="#roadsresponse">Response</a> object
On failure, you should receive an error. This error might be an <a href="#roadshttperror">HttpError</a></p>

<p><strong>NOTE:</strong> The response data will already be processed at this point through <a href="#responsegetdata"><code>getData()</code></a> and <a href="#roadsfieldsfilter"><code>FieldsFilter</code></a>. You should reference <code>response.data</code> directly, and not use <code>getData()</code>.</p>

<pre><code>var promise = api.request('GET', '/users/dashron');

promise.then(function (response) {        
    console.log(response.data);
});

promise.catch(function (err) {
    console.log(err);
});
</code></pre>

<h3>
<a name="apiserverincomingmessage-http_request-serverresponse-http_response" class="anchor" href="#apiserverincomingmessage-http_request-serverresponse-http_response"><span class="octicon octicon-link"></span></a>API.server(<em>IncomingMessage</em> http_request, <em>ServerResponse</em> http_response)</h3>

<p><strong>An onRequest callback for http.createServer()</strong></p>

<p>Helper function so the api can be thrown directly into http.createServer.</p>

<pre><code>require('http').createServer(api.server.bind(api))
    .listen(8081, function () {
        console.log('server has started');
    });
</code></pre>

<h2>
<a name="roadsresource" class="anchor" href="#roadsresource"><span class="octicon octicon-link"></span></a>Roads.Resource</h2>

<p>Each resource represents a single endpoint. The definition provided to the constructor defines how the resource operates, and all methods exposed on a resource are intended to be used by other parts of the roads framework.</p>

<h3>
<a name="new-resourceobject-definition" class="anchor" href="#new-resourceobject-definition"><span class="octicon octicon-link"></span></a>new Resource(<em>Object</em> definition)</h3>

<p><strong>Constructor</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>definition</td>
<td>object</td>
<td>A definition which describes how the resource should operate</td>
</tr>
</tbody>
</table>

<p>The definition only looks for two fields.</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>resources</td>
<td>object</td>
<td>Each key is a <a href="#url-part">url part</a>, and each value is a sub-<a href="#roadsresource">resource</a>
</td>
</tr>
<tr>
<td>methods</td>
<td>object</td>
<td>Each key is an HTTP method, and each value is a <a href="#resource-method">resource method</a>.</td>
</tr>
</tbody>
</table>

<pre><code>module.exports.many = new Resource({
    resources : {
        'users' : require('./users').many,
        'posts' : require('./posts').many
    },
    methods : {
        GET : function* (url, body, headers) {
            return new Response({
                "users" : "/users",
                "posts" : "/posts"
            });
        }
    }
});
</code></pre>

<h4>
<a name="url-part-routing" class="anchor" href="#url-part-routing"><span class="octicon octicon-link"></span></a>URL Part (routing)</h4>

<p>All URL routing happens through the resource definition, and through sub resources. The root resource represents a url without any path ([protocol]://[host]/). This root resource must define additional resources as sub resources, which will branch out after the root resource.</p>

<table>
<thead>
<tr>
<th>Part</th>
<th>Example</th>
<th>Example values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>{literal}</td>
<td>users</td>
<td>users</td>
<td>The provided value must explicitly match the <a href="#url-part">url part</a>
</td>
</tr>
<tr>
<td>#{key}</td>
<td>#user_id</td>
<td>12445</td>
<td>The provided value must be numeric</td>
</tr>
<tr>
<td>${key}</td>
<td>#username</td>
<td>dashron</td>
<td>The provided value can be any series of non-forward slash, url valid characters</td>
</tr>
</tbody>
</table>

<p>In the following example, the only valid urls are /, /users and /users/{number}</p>

<pre><code>var single = new Resource({
});

var many = new Resource({
    resources : {
        "#user_id" : single
    }
});

var root = new Resource({
    resources : {
        "users" : many
    }
});
</code></pre>

<p>For variable fields, you can retrieve the variable in the url parameter. The url parameter will be an object, and will have an "args" parameter</p>

<pre><code>var single = new Resource({
    methods : function (url, body, headers) {
        console.log(url.args.user_id);
    }
});

var many = new Resource({
    resources : {
        "#user_id" : single
    }
});

var root = new Resource({
    resources : {
        "users" : many
    }
});
</code></pre>

<h4>
<a name="resource-method" class="anchor" href="#resource-method"><span class="octicon octicon-link"></span></a>Resource Method</h4>

<p>Each <code>method : function</code> pair of the methods field describes how the API server will respond to an HTTP request. The function is called a "resource method". Resource methods must return a promise.</p>

<p>If a method could not be located for the provided URL and method, the API will throw an HttpError. The error's message will contain all of the valid methods, and the status code will be 405.</p>

<p>Each resource method has access to the request context through <code>this</code>. Each <code>this</code> will be unique to the request, and will persist from the requestHandler into the actual request. Feel free to add any methods you want to this context, one is already provided. The request method of API.request can be called directly from within your resource method by calling <code>this.request</code>. This request will receive it's own unique context, because I have not spent the time to make it work otherwise. If you think it would be useful to persist a single context through sub-requests let me know!</p>

<pre><code>var api = new API(new Resource({
    methods : {
        GET : function (url, body, headers) {
            return this.request('GET', this.uri);
        }
    }
}));

api.onRequest(function* (method, url, body, headers, next) {
    this.uri = '/me';
    return yield next();
});
</code></pre>

<h2>
<a name="roadsresponse" class="anchor" href="#roadsresponse"><span class="octicon octicon-link"></span></a>Roads.Response</h2>

<p>The response object contains all of the information you want to send to the client. This includes the body, status code and all applicable headers. </p>

<h3>
<a name="new-responsedynamic-data-number-status-object-headers" class="anchor" href="#new-responsedynamic-data-number-status-object-headers"><span class="octicon octicon-link"></span></a>new Response(<em>dynamic</em> data, <em>number</em> status, <em>Object</em> headers)</h3>

<p><strong>Constructor</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>dynamic</td>
<td>A definition which describes how the resource should operate</td>
</tr>
<tr>
<td>status</td>
<td>number</td>
<td>The HTTP Status code</td>
</tr>
<tr>
<td>headers</td>
<td>object</td>
<td>Key value pairs of http headers.</td>
</tr>
</tbody>
</table>

<p>Create a response object. </p>

<pre><code>new Response({"uri" : "..."}, 200, {"last-modified":"2014-04-27 00:00:00"});
</code></pre>

<h3>
<a name="responsegetdata" class="anchor" href="#responsegetdata"><span class="octicon octicon-link"></span></a>Response.getData()</h3>

<p><strong>Get the final data from the response, after all parsing</strong></p>

<p>The result will always be a <a href="http://wiki.commonjs.org/wiki/Promises/A">thenable (Promises/A compatible promise)</a>, no matter what data has been provided to the Response object.</p>

<p><strong>NOTE:</strong> The <a href="#apirequeststring-method-string-url-dynamic-body-object-headers">request</a> method will have already called <code>getData()</code>. <code>getData()</code> is only useful if you have not yet called request, but need to expand a response object. If you call this, I highly recommend assigning the final value back into response.data, so that you do not have to process the response data multiple times. </p>

<pre><code>// Get the data, which will be a promise
return response.getData()
    .then(function (data) {
        console.log(data);
        // NOTE: If any of your values are functions or promises, you must pass them through the field filter for them to be properly expanded.
    });
</code></pre>

<h3>
<a name="responsewritetoserverserverresponse-http_response" class="anchor" href="#responsewritetoserverserverresponse-http_response"><span class="octicon octicon-link"></span></a>Response.writeToServer(<em>ServerResponse</em> http_response)</h3>

<p><strong>A helper function to write the response object to a server response</strong></p>

<p>This will apply the body, status code, and any applicable headers to the provided http_response. It will not end the response, so you need to do that yourself.</p>

<pre><code>// execute the api logic and retrieve the appropriate response object
api.request(http_request.method, http_request.url, body, http_request.headers)
    .then(function (response) {
        // Get the data, which will be a promise
        response.writeToServer(http_response);
        http_response.end();
    });
</code></pre>

<h2>
<a name="roadsfieldsfilter" class="anchor" href="#roadsfieldsfilter"><span class="octicon octicon-link"></span></a>Roads.FieldsFilter</h2>

<p>Many APIs benefit from allowing users to limit which fields they want. If a user is only trying to display title and description, there's no need to provide tons of unrelated stats and metadata. This is the first benefit of the fields filter. When provided the response data of a route, and an array of valid fields, The field filter will remove any unwanted fields.</p>

<pre><code>var f = new FieldsFilter({
    'test' : {
        'one' : true,
        'two' : true
    },
    'hello' : {
        'one' : true,
        'two' : true
    }
});

// notice test.two was not requested, so it's ignored
// notice hello was requested, so the entire child resource is provided
f.filter(['test.one', 'hello'])
    .then(function (response) {
        console.log(response === {
            'test' : {
                'one' : true
            },
            'hello' : {
                'one' : true,
                'two' : true
            }
        });
    });
</code></pre>

<p>The second benefit is that you can provide function or promise values and the filter will expand them ONLY if the user has explicitly requested them. This allows you to avoid heavy DB queries or cache hits by intelligently structuring your responses.</p>

<pre><code>var f = new FieldsFilter({
    'test' : {
        'one' : function () {
            return true;
        },
        'two' : function () {
            console.log('this will never be reached!');
            return true;
        }
    },
    'hello' : {
        'one' : true,
        'two' : true
    }
});

// notice test.two was not requested, so it's ignored and the function is never executed
// notice test.one was requested, so the function is executed and the response is provided
f.filter(['test.one', 'hello'])
    .then(function (response) {
        console.log(response === {
            'test' : {
                'one' : true
            },
            'hello' : {
                'one' : true,
                'two' : true
            }
        });
    });
</code></pre>

<h3>
<a name="new-fieldsfilterdynamic-data" class="anchor" href="#new-fieldsfilterdynamic-data"><span class="octicon octicon-link"></span></a>new FieldsFilter(<em>dynamic</em> data)</h3>

<p><strong>Create an object to help filter down a set of data</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>dynamic</td>
<td>A piece of data that needs to be expanded and or filtered</td>
</tr>
</tbody>
</table>

<pre><code>var f = new FieldsFilter({"hello" : "goodbye"});
</code></pre>

<h3>
<a name="filterarray-fields" class="anchor" href="#filterarray-fields"><span class="octicon octicon-link"></span></a>filter(<em>Array</em> fields)</h3>

<p><strong>Filter down a set of data based on a whitelist of fields</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fields</td>
<td>dynamic</td>
<td>An array of fields that should remain in the response. To represent a heirarchy use periods</td>
</tr>
</tbody>
</table>

<p>Reduce the data associated with this filter object to only contain the fields provided in the "fields" array
If true is passed, the whole object will be expanded and all fields returned.</p>

<pre><code>var f = new FieldsFilter({
    'test' : {
        'one' : true,
        'two' : true
    },
    'hello' : {
        'one' : true,
        'two' : true
    }
});

f.filter(['test.one', 'hello'])
    .then(function (response) {
        console.log(response === {
            'test' : {
                'one' : true
            },
            'hello' : {
                'one' : true,
                'two' : true
            }
        });
    });
</code></pre>

<h2>
<a name="roadshttperror" class="anchor" href="#roadshttperror"><span class="octicon octicon-link"></span></a>Roads.HttpError</h2>

<h3>
<a name="new-httperrorstring-message-number-code" class="anchor" href="#new-httperrorstring-message-number-code"><span class="octicon octicon-link"></span></a>new HttpError(<em>string</em> message, <em>number</em> code)</h3>

<p><strong>A helper error, that contains information relevant to common HTTP errors</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>string</td>
<td>A message describing the HTTP error</td>
</tr>
<tr>
<td>code</td>
<td>number</td>
<td>An official http status code</td>
</tr>
</tbody>
</table>

<pre><code>throw new Roads.HttpError('Page not found', 404);
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Roads maintained by <a href="https://github.com/Dashron">Dashron</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-45276947-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
