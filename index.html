<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Roads : A node.js web framework">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Roads</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Dashron/roads">View on GitHub</a>

          <h1 id="project_title">Roads</h1>
          <h2 id="project_tagline">A node.js web framework</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Dashron/roads/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Dashron/roads/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="the-roadsjs-api-framework" class="anchor" href="#the-roadsjs-api-framework"><span class="octicon octicon-link"></span></a>The Roads.js API Framework</h1>

<p>Roads is a framework for creating APIs in node.js. It requires generator support, so you should be using node 0.11.13 or higher with the <code>--harmony</code> flag enabled.</p>

<h1>
<a name="why-should-i-use-roads" class="anchor" href="#why-should-i-use-roads"><span class="octicon octicon-link"></span></a>Why should I use Roads?</h1>

<ol>
<li>It helps build an organized, resource oriented API through a nested routing structure.</li>
<li>It can be required right from your code, or called over HTTP.</li>
<li>It is built using generators and promises so that you never have to worry about callbacks.</li>
<li>Can be used with roads-fieldsfilter to support lazy responses, only executing the code your users need.</li>
</ol>

<h1>
<a name="index" class="anchor" href="#index"><span class="octicon octicon-link"></span></a>Index</h1>

<ul>
<li><a href="#gettingstarted">Getting Started</a></li>
<li>
<a href="#roadsapi">Roads.API</a>

<ul>
<li><a href="#new-apiresource-root_resource">new API(<em>Resource</em> root_resource)</a></li>
<li><a href="#apionrequestfunction-fn">onRequest(<em>Function</em> fn)</a></li>
<li><a href="#apirequeststring-method-string-url-dynamic-body-object-headers">request(<em>string</em> method, <em>string</em> url, <em>dynamic</em> body, <em>Object</em> headers)</a></li>
<li><a href="#apiserverincomingmessage-http_request-serverresponse-http_response">server(<em>IncomingMessage</em> http_request, <em>ServerResponse</em> http_response)</a></li>
</ul>
</li>
<li>
<a href="#roadsresource">Roads.Resource</a>

<ul>
<li><a href="#new-resourceobject-definition">new Resource(<em>Object</em> definition)</a></li>
<li><a href="#url-part">URL Part (routing)</a></li>
<li><a href="#resource-method">Resource method</a></li>
</ul>
</li>
<li>
<a href="#roadsresponse">Roads.Response</a>

<ul>
<li><a href="#new-responsedynamic-data-number-status-object-headers">new Response(<em>Object</em> data, <em>number</em> status, <em>Object</em> headers)</a></li>
<li><a href="#responsewritetoserverserverresponse-http_response">writeTo(<em>ServerResponse</em> httpResponse)</a></li>
</ul>
</li>
<li>
<a href="#roadshttperror">Roads.HttpError</a>

<ul>
<li><a href="#new-httperrorstring-message-number-code">new HttpError(<em>string</em> message, <em>number</em> code)</a></li>
</ul>
</li>
<li><a href="#performance-improvements">Performance Improvements</a></li>
</ul>

<h2>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<p>Building an API with roads follows a fairly simple workflow.</p>

<ol>
<li>Create a <a href="#roadsresource">Resource</a> object for every endpoint (<code>/</code>, <code>/users</code>, <code>/posts</code>, <code>/users/#user_id</code>)</li>
</ol>

<pre><code>    // Create your resource.
    var resource = new roads.Resource({
        // Define sub-resources.
        resources : {
            // This implies that the files "users.js" and "posts.js" contain resource objects.
            "users" : require('./users'),
            "posts" : require('./posts')
        },
        // Incomplete. See step 2.
        methods : ...
    });

    // Assign your resource to the root "/" endpoint.
    var api = new roads.API(resource);
</code></pre>

<ol>
<li>Each <a href="#roadsresource">Resource</a> from step #1 should contain one or more <a href="#resource-method">resource methods</a>. Each resource method is associated with an HTTP method.</li>
</ol>

<pre><code>    var resource = new roads.Resource({
        // Incomplete. See step 1.
        resources : ...,
        methods : {
            GET : function (url, body, headers) {
                // URL query string parameter.
                url.query.page;

                // JSON or query string body, parsed depending on the content-type header.
                body.name;

                // Incomplete, see step 3.
                return ...
            }
        }
    });
</code></pre>

<ol>
<li>Each <a href="#resource-method">resource method</a> from step #2 should return a <a href="#roadsresponse">response</a> object. </li>
</ol>

<pre><code>    var resource = new roads.Resource({
        // Incomplete. See step 1.
        resources : ...,
        methods : {
            GET : function (url, body, headers) {
                // Incomplete, see step 2.
                ...

                // Build a response object, with the body, status code and headers.
                return new roads.Resource({ "name" : "aaron" }, 200, {"last-modified" : "Tue, 15 Nov 1994 12:45:26 GMT"});
            }
        }
    });
</code></pre>

<ol>
<li>Tie the API to an HTTP server</li>
</ol>

<pre><code>    require('http').createServer(api.server.bind(api))
        .listen(8080, function () {
            console.log('server has started');
        });
</code></pre>

<p>Once all of these steps are complete, you should be able to access the API through your browser. Continue reading the docs below for more information on <a href="#apionrequestfunction-fn">error handling</a>, <a href="#url-part">URL parameters</a> and more!</p>

<h2>
<a name="roadsapi" class="anchor" href="#roadsapi"><span class="octicon octicon-link"></span></a>Roads.API</h2>

<p>The API is a container that holds a hierarchy of <a href="#roadsresource">Resource</a> objects. It exposes a <a href="#apirequeststring-method-string-url-dynamic-body-object-headers">request</a> method which allows you to interact directly with the resources.</p>

<p>You must provide the root resource to the constructor. This resource will resolve any requests to the root (<code>/</code>) endpoint. Any additional routes will be referenced as sub-resources of the root endpoint.</p>

<h3>
<a name="new-apiresource-root_resource" class="anchor" href="#new-apiresource-root_resource"><span class="octicon octicon-link"></span></a>new API(<em>Resource</em> root_resource)</h3>

<p><strong>Create an API object.</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>root_resource</td>
<td><a href="#roadsresource">Resource</a></td>
<td>yes</td>
<td>Used to generate the <a href="#roadsresponse">response</a> for the root endpoint ( [protocol]://[host]/ ).</td>
</tr>
</tbody>
</table>

<p>Creates your API object. You must provide a <a href="#roadsresource">Resource</a> to the constructor. The provided resource becomes the root resource, and will be used for any API requests to <code>/</code>.</p>

<pre lang="node"><code>var roads = require('roads');
var root_resource = new roads.Resource(...); // The resource definition has not been set here, because it's out of the scope of this example. Take a look at [Resource](#roadsresource) for information about the Resource constructor.
var api = new roads.API(root_resource);
</code></pre>

<h3>
<a name="apionrequestfunction-fn" class="anchor" href="#apionrequestfunction-fn"><span class="octicon octicon-link"></span></a>API.onRequest(<em>Function</em> fn)</h3>

<p><strong>Add a custom function to be executed along with every request.</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>required</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>Function(<em>string</em> method, <em>string</em> url,<em>object</em> body,<em>object</em> headers,<em>function</em> next)</td>
<td>yes</td>
<td>Will be called any time a request is made on the API object.</td>
</tr>
</tbody>
</table>

<p>This will be called for every request, even for routes that do not exist. The callback will be executed with the following five parameters :</p>

<h4>
<a name="onrequest-callback" class="anchor" href="#onrequest-callback"><span class="octicon octicon-link"></span></a>onRequest Callback</h4>

<p><strong>function (<em>string</em> method,<em>string</em> url, <em>Object</em> body, <em>Object</em> headers, <em>Function</em> next)</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>method</td>
<td>string</td>
<td>The HTTP method that was provided to the request</td>
</tr>
<tr>
<td>url</td>
<td>string</td>
<td>The URL that was provided to the request</td>
</tr>
<tr>
<td>body</td>
<td>object</td>
<td>The body that was provided to the request, after it was properly parsed into an object</td>
</tr>
<tr>
<td>headers</td>
<td>object</td>
<td>The headers that were provided to the request</td>
</tr>
<tr>
<td>next</td>
<td>function</td>
<td>The <a href="#resource-method">resource method</a> that the router located. Execute this function to perform the standard API action for this HTTP method and URL. This method will always return a promise.</td>
</tr>
</tbody>
</table>

<p>If the callback does not return a <a href="#roadsresponse">response</a> object, it will be wrapped in a <a href="#roadsresponse">response</a> object with the default status code of 200.</p>

<pre><code>// Example of an onRequest handler
api.onRequest(function* (url, body, headers, next) {
    // kill trailing slash as long as we aren't at the root level
    if (url.path != '/' &amp;&amp; url.path[url.path.length - 1] === '/') {
        return new roads.Response(null, 302, {
            location : url.path.substring(0, url.path.length - 1)
        });
    }

    // This would also be a good place to identify the authenticated user, or API app and add it to the current request context
    // eg: this.cur_user = user;

    // execute the actual resource method, and return the response
    return next()
        // Catch any errors that are thrown by the resources
        .catch (function (err) {
            // Wrap the errors in response objects. If they are [HttpErrors](#roadshttperror) we adjust the status code
            switch (err.code) {
                case 404:
                    return new roads.Response(notFoundRepresentation(err), 404);
                case 405:
                    return new roads.Response(notAllowedRepresentation(err), 405);
                case 500:
                default:
                    return new roads.Response(unknownRepresentation(err), 500);
            }
        });
});
</code></pre>

<h3>
<a name="apirequeststring-method-string-url-dynamic-body-object-headers" class="anchor" href="#apirequeststring-method-string-url-dynamic-body-object-headers"><span class="octicon octicon-link"></span></a>API.request(<em>string</em> method, <em>string</em> url, <em>dynamic</em> body, <em>Object</em> headers)</h3>

<p><strong>Make a request to the API.</strong></p>

<p>This function will locate the appropriate <a href="#resource-method">resource method</a> for the provided HTTP Method and URL, execute it and return a <a href="http://wiki.commonjs.org/wiki/Promises/A">thenable (Promises/A compatible promise)</a>. It will always return a <a href="#roadsresponse">Response</a> object.</p>

<pre><code>var promise = api.request('GET', '/users/dashron');

promise.then(function (response) {        
    console.log(response.data);
});

promise.catch(function (error) {
    console.log(error);
});
</code></pre>

<h3>
<a name="apiserverincomingmessage-http_request-serverresponse-http_response" class="anchor" href="#apiserverincomingmessage-http_request-serverresponse-http_response"><span class="octicon octicon-link"></span></a>API.server(<em>IncomingMessage</em> http_request, <em>ServerResponse</em> http_response)</h3>

<p><strong>An onRequest callback for http.createServer()</strong></p>

<p>Helper function so the API can be thrown directly into http.createServer.</p>

<pre><code>require('http').createServer(api.server.bind(api))
    .listen(8081, function () {
        console.log('server has started');
    });
</code></pre>

<h2>
<a name="roadsresource" class="anchor" href="#roadsresource"><span class="octicon octicon-link"></span></a>Roads.Resource</h2>

<p>Each resource represents a single endpoint. The definition provided to the constructor describes how it can be used by the API object.</p>

<h3>
<a name="new-resourceobject-definition" class="anchor" href="#new-resourceobject-definition"><span class="octicon octicon-link"></span></a>new Resource(<em>Object</em> definition)</h3>

<p><strong>Constructor</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>definition</td>
<td>object</td>
<td>A definition which describes how the resource should operate</td>
</tr>
</tbody>
</table>

<p>The definition only looks for two fields.</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>resources</td>
<td>object</td>
<td>Each key is a <a href="#url-part">URL part</a>, and each value is a sub-<a href="#roadsresource">resource</a>
</td>
</tr>
<tr>
<td>methods</td>
<td>object</td>
<td>Each key is an HTTP method, and each value is a <a href="#resource-method">resource method</a>.</td>
</tr>
</tbody>
</table>

<pre><code>module.exports.many = new Resource({
    resources : {
        'users' : require('./users').many,
        'posts' : require('./posts').many
    },
    methods : {
        GET : function* (url, body, headers) {
            return new Response({
                "users" : "/users",
                "posts" : "/posts"
            });
        }
    }
});
</code></pre>

<h4>
<a name="url-part-routing" class="anchor" href="#url-part-routing"><span class="octicon octicon-link"></span></a>URL Part (routing)</h4>

<p>All URL routing happens through the resource definition, and through sub resources. The root resource represents a URL without any path ([protocol]://[host]/). This root resource must define additional resources as sub resources, which will branch out after the root resource.</p>

<table>
<thead>
<tr>
<th>Part</th>
<th>Example</th>
<th>Example values</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>{literal}</td>
<td>users</td>
<td>users</td>
<td>The provided value must explicitly match the <a href="#url-part">URL part</a>
</td>
</tr>
<tr>
<td>#{key}</td>
<td>#user_id</td>
<td>12445</td>
<td>The provided value must be numeric</td>
</tr>
<tr>
<td>${key}</td>
<td>#username</td>
<td>dashron</td>
<td>The provided value can be any series of non-forward slash, URL valid characters</td>
</tr>
</tbody>
</table>

<p>In the following example, the only valid URLs are /, /users and /users/{number}</p>

<pre><code>var single = new Resource({
});

var many = new Resource({
    resources : {
        "#user_id" : single
    }
});

var root = new Resource({
    resources : {
        "users" : many
    }
});
</code></pre>

<p>For variable fields, you can retrieve the variable in the URL parameter. The URL parameter will be an object, and will have an "args" parameter</p>

<pre><code>var single = new Resource({
    methods : function (url, body, headers) {
        console.log(url.args.user_id);
    }
});

var many = new Resource({
    resources : {
        "#user_id" : single
    }
});

var root = new Resource({
    resources : {
        "users" : many
    }
});
</code></pre>

<h4>
<a name="resource-method" class="anchor" href="#resource-method"><span class="octicon octicon-link"></span></a>Resource Method</h4>

<p>Each <code>method : function</code> pair of the methods field describes how the API server will respond to an HTTP request. The function is called a "resource method".</p>

<p>If a resource could not be located for the provided URL, the API will throw an <a href="#roadshttperror">HttpError</a> with a 404 status code.
If a resource was located for the provided URL, but the resource did not have the appropriate <a href="#resource-method">resource method</a> for the requested HTTP method, the API will throw an <a href="#roadshttperror">HttpError</a> with a 405 status code.</p>

<p>Each resource method has access to a request context through <code>this</code>. Each <code>this</code> will be unique to the request, and will persist from the requestHandler into the actual request. The context is pre-loaded with a request method, which is an alias for <a href="#apirequeststring-method-string-url-dynamic-body-object-headers">API.request</a>. You may add any additional methods or properties to the context.</p>

<pre><code>var api = new API(new Resource({
    methods : {
        GET : function (url, body, headers) {
            // true
            console.log(this.uri === '/me');
        }
    }
}));

api.onRequest(function* (method, url, body, headers, next) {
    this.uri = '/me';
    return yield next();
});
</code></pre>

<h2>
<a name="roadsresponse" class="anchor" href="#roadsresponse"><span class="octicon octicon-link"></span></a>Roads.Response</h2>

<p>The response object contains all of the information you want to send to the client. This includes the body, status code and all applicable headers. </p>

<h3>
<a name="new-responsedynamic-data-number-status-object-headers" class="anchor" href="#new-responsedynamic-data-number-status-object-headers"><span class="octicon octicon-link"></span></a>new Response(<em>dynamic</em> data, <em>number</em> status, <em>Object</em> headers)</h3>

<p><strong>Constructor</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>dynamic</td>
<td>The body of the response. If provided a JavaScript object, and no content-type header, the response will be sent through JSON.stringify, and the content-type header will be set to <code>application/json</code>
</td>
</tr>
<tr>
<td>status</td>
<td>number</td>
<td>The HTTP Status code</td>
</tr>
<tr>
<td>headers</td>
<td>object</td>
<td>Key value pairs of http headers.</td>
</tr>
</tbody>
</table>

<p>Create a response object. </p>

<pre><code>new Response({"uri" : "..."}, 200, {"last-modified":"2014-04-27 00:00:00"});
</code></pre>

<h3>
<a name="responsewritetoserverserverresponse-http_response" class="anchor" href="#responsewritetoserverserverresponse-http_response"><span class="octicon octicon-link"></span></a>Response.writeToServer(<em>ServerResponse</em> http_response)</h3>

<p><strong>A helper function to write the response object to a server response</strong></p>

<p>This will apply the body, status code, and any applicable headers to the provided http_response. It will not end the response, so you need to do that yourself.</p>

<pre><code>// execute the API logic and retrieve the appropriate response object
api.request(http_request.method, http_request.url, body, http_request.headers)
    .then(function (response) {
        // Get the data
        response.writeToServer(http_response);
        http_response.end();
    })
    .catch(function (error) {
        // be careful throwing an error in a response like this
        // errors might expose sensitive data
        (new roads.Response(error, 500)).writeToServer(http_response);
        http_response.end();
    });
</code></pre>

<h2>
<a name="roadshttperror" class="anchor" href="#roadshttperror"><span class="octicon octicon-link"></span></a>Roads.HttpError</h2>

<h3>
<a name="new-httperrorstring-message-number-code" class="anchor" href="#new-httperrorstring-message-number-code"><span class="octicon octicon-link"></span></a>new HttpError(<em>string</em> message, <em>number</em> code)</h3>

<p><strong>A helper error, that contains information relevant to common HTTP errors</strong></p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>string</td>
<td>A message describing the HTTP error</td>
</tr>
<tr>
<td>code</td>
<td>number</td>
<td>An official http status code</td>
</tr>
</tbody>
</table>

<pre><code>throw new Roads.HttpError('Page not found', 404);
</code></pre>

<h3>
<a name="performance-improvements" class="anchor" href="#performance-improvements"><span class="octicon octicon-link"></span></a>Performance improvements</h3>

<p>It's possible to design your API responses to achieve significant performance gains. <a href="https://github.com/Dashron/roads-fieldsfilter">Roads Fields Filter</a> helps facilitate that feature.</p>

<h3>
<a name="todo" class="anchor" href="#todo"><span class="octicon octicon-link"></span></a>TODO</h3>

<p>Next step is to build roads-client, a single library that can be run in node, or browsers and can communicate with APIs built on roads. It will expose at least one method, which will have a call signature identical to <a href="#apirequeststring-method-string-url-dynamic-body-object-headers">API.request</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Roads maintained by <a href="https://github.com/Dashron">Dashron</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-45276947-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
